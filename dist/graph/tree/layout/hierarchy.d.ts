import type { Direction } from '../types';
export type Methods = Partial<typeof extend>;
export interface NodeType extends Methods {
    id: string;
    name?: string;
    label?: string;
    preH?: number;
    preV?: number;
    hgap?: number;
    vgap?: number;
    width?: number;
    height?: number;
    x?: number;
    y?: number;
    index?: number;
    w?: number;
    h?: number;
    tl?: NodeType;
    tr?: NodeType;
    msel?: number;
    mser?: number;
    mod?: number;
    low?: number;
    shift?: number;
    change?: number;
    prelim?: number;
    startY?: number;
    depth?: number;
    drawingDepth?: number;
    collapsed?: boolean;
    side?: 'left' | 'right';
    data?: any;
    originNode?: NodeType;
    parent?: NodeType;
    el?: NodeType;
    leftChild?: NodeType;
    er?: NodeType;
    rightChild?: NodeType;
    c?: Array<NodeType>;
    cs?: number;
    children?: Array<NodeType>;
    totalHeight?: number;
    _subTreeSep?: number;
    ih?: {
        low: number;
        index: number;
        nxt: NodeType['ih'];
    };
    nxt?: NodeType['ih'];
    [key: string]: any;
}
export type Options = Partial<typeof DEFAULT_OPTIONS> & {
    direction?: Direction;
    isHorizontal?: boolean;
    forceCompact?: boolean;
    fixedRoot?: boolean;
    indent?: number;
    dropCap?: boolean;
    align?: 'center';
    getSubTreeSep?: (data?: any) => number;
    getSide?: (child: NodeType, index: number) => 'left' | 'right';
};
declare const DEFAULT_OPTIONS: {
    readonly getId: (d: NodeType) => string;
    readonly getPreH: (d: NodeType) => number;
    readonly getPreV: (d: NodeType) => number;
    readonly getHGap: (d: NodeType) => number;
    readonly getVGap: (d: NodeType) => number;
    readonly getChildren: (d: NodeType) => NodeType[];
    readonly getHeight: (d: NodeType) => number;
    readonly getWidth: (d: NodeType) => number;
};
declare const extend: {
    isRoot(): boolean;
    isLeaf(): boolean;
    addGap(hgap: number, vgap: number): void;
    eachNode(callback: (v: NodeType) => void): void;
    DFTraverse(callback: (v: NodeType) => void): void;
    BFTraverse(callback: (v: NodeType) => void): void;
    getBoundingBox(): {
        left: number;
        top: number;
        width: number;
        height: number;
    };
    translate(tx?: number, ty?: number): void;
    right2left(): void;
    bottom2top(): void;
};
export declare const hierarchy: (data: NodeType, options?: Options, isolated?: boolean) => NodeType;
export {};
