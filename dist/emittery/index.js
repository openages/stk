var u=new WeakMap,d=new WeakMap,f=new WeakMap;var E=Symbol("anyProducer"),P=Promise.resolve(),w=Symbol("listenerAdded"),v=Symbol("listenerRemoved"),A=!1,D=!1;function l(e){if(typeof e!=="string"&&typeof e!=="symbol"&&typeof e!=="number")throw new TypeError("`eventName` must be a string, symbol, or number")}function p(e){if(typeof e!=="function")throw new TypeError("listener must be a function")}function c(e,t){let n=d.get(e);if(!n.has(t))return;return n.get(t)}function b(e,t){let n=typeof t==="string"||typeof t==="symbol"||typeof t==="number"?t:E,r=f.get(e);if(!r.has(n))return;return r.get(n)}function k(e,t,n){let r=f.get(e);if(r.has(t))for(let s of r.get(t))s.enqueue(n);if(r.has(E)){let s=Promise.all([t,n]);for(let i of r.get(E))i.enqueue(s)}}function M(e,t){t=Array.isArray(t)?t:[t];let n=!1,r=(...o)=>{},s=[],i={enqueue(o){s.push(o),r()},finish(){n=!0,r()}};for(let o of t){let a=b(e,o);if(!a)a=new Set,f.get(e).set(o,a);a.add(i)}return{async next(){if(!s)return{done:!0};if(s.length===0){if(n)return s=void 0,this.next();return await new Promise((o)=>{r=o}),this.next()}return{done:!1,value:await s.shift()}},async return(o){s=void 0;for(let a of t){let h=b(e,a);if(h){if(h.delete(i),h.size===0)f.get(e).delete(a)}}return r(),arguments.length>0?{done:!0,value:await o}:{done:!0}},[Symbol.asyncIterator](){return this}}}function S(e){if(e===void 0)return O;if(!Array.isArray(e))throw new TypeError("`methodNames` must be an array of strings");for(let t of e)if(!O.includes(t)){if(typeof t!=="string")throw new TypeError("`methodNames` element must be a string");throw new Error(`${t} is not Emittery method`)}return e}var y=(e)=>e===w||e===v;function m(e,t,n){if(y(t))try{A=!0,e.emit(t,n)}finally{A=!1}}class g{static listenerAdded;static listenerRemoved;debug={};static get isDebugEnabled(){if(typeof globalThis.process?.env!=="object")return D;let{env:e}=globalThis.process??{env:{}};return e.DEBUG==="emittery"||e.DEBUG==="*"||D}static set isDebugEnabled(e){D=e}constructor(e={}){if(u.set(this,new Set),d.set(this,new Map),f.set(this,new Map),f.get(this).set(E,new Set),this.debug=e.debug??{},this.debug.enabled===void 0)this.debug.enabled=!1;if(!this.debug.logger)this.debug.logger=(t,n,r,s)=>{try{s=JSON.stringify(s)}catch{s=`Object with the following keys failed to stringify: ${Object.keys(s).join(",")}`}if(typeof r==="symbol"||typeof r==="number")r=r.toString();let i=new Date,o=`${i.getHours()}:${i.getMinutes()}:${i.getSeconds()}.${i.getMilliseconds()}`;console.log(`[${o}][emittery:${t}][${n}] Event Name: ${r}\n\tdata: ${s}`)}}logIfDebugEnabled(e,t,n){if(g.isDebugEnabled||this.debug.enabled)this.debug.logger(e,this.debug.name,t,n)}on(e,t){p(t),e=Array.isArray(e)?e:[e];for(let n of e){l(n);let r=c(this,n);if(!r)r=new Set,d.get(this).set(n,r);if(r.add(t),this.logIfDebugEnabled("subscribe",n,void 0),!y(n))m(this,w,{eventName:n,listener:t})}return this.off.bind(this,e,t)}off(e,t){p(t),e=Array.isArray(e)?e:[e];for(let n of e){l(n);let r=c(this,n);if(r){if(r.delete(t),r.size===0)d.get(this).delete(n)}if(this.logIfDebugEnabled("unsubscribe",n,void 0),!y(n))m(this,v,{eventName:n,listener:t})}}once(e){let t,n=new Promise((r)=>{t=this.on(e,(s)=>{t(),r(s)})});return n.off=t,n}events(e){e=Array.isArray(e)?e:[e];for(let t of e)l(t);return M(this,e)}async emit(e,t){if(l(e),y(e)&&!A)throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");this.logIfDebugEnabled("emit",e,t),k(this,e,t);let n=c(this,e)??new Set,r=u.get(this),s=[...n],i=y(e)?[]:[...r];await P;let o=await Promise.all([...s.map(async(a)=>{if(n.has(a))return a(t)}),...i.map(async(a)=>{if(r.has(a))return a(e,t)})]);if(o.length===1)return o[0];return o}async emitSerial(e,t){if(l(e),y(e)&&!A)throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");this.logIfDebugEnabled("emitSerial",e,t);let n=c(this,e)??new Set,r=u.get(this),s=[...n],i=[...r];await P;for(let o of s)if(n.has(o))await o(t);for(let o of i)if(r.has(o))await o(e,t)}onAny(e){return p(e),this.logIfDebugEnabled("subscribeAny",void 0,void 0),u.get(this).add(e),m(this,w,{listener:e}),this.offAny.bind(this,e)}anyEvent(){return M(this)}offAny(e){p(e),this.logIfDebugEnabled("unsubscribeAny",void 0,void 0),m(this,v,{listener:e}),u.get(this).delete(e)}clearListeners(e){e=Array.isArray(e)?e:[e];for(let t of e)if(this.logIfDebugEnabled("clear",t,void 0),typeof t==="string"||typeof t==="symbol"||typeof t==="number"){let n=c(this,t);if(n)n.clear();let r=b(this,t);if(r){for(let s of r)s.finish();r.clear()}}else{u.get(this).clear();for(let[n,r]of d.get(this).entries())r.clear(),d.get(this).delete(n);for(let[n,r]of f.get(this).entries()){for(let s of r)s.finish();r.clear(),f.get(this).delete(n)}}}listenerCount(e){e=Array.isArray(e)?e:[e];let t=0;for(let n of e){if(typeof n==="string"){t+=u.get(this).size+(c(this,n)?.size??0)+(b(this,n)?.size??0)+(b(this)?.size??0);continue}if(typeof n!=="undefined")l(n);t+=u.get(this).size;for(let r of d.get(this).values())t+=r.size;for(let r of f.get(this).values())t+=r.size}return t}bindMethods(e,t){if(typeof e!=="object"||e===null)throw new TypeError("`target` must be an object");t=S(t);for(let n of t){if(e[n]!==void 0)throw new Error(`The property \`${n}\` already exists on \`target\``);Object.defineProperty(e,n,{enumerable:!1,value:this[n].bind(this)})}}}var O=Object.getOwnPropertyNames(g.prototype).filter((e)=>e!=="constructor");Object.defineProperty(g,"listenerAdded",{value:w,writable:!1,enumerable:!0,configurable:!1});Object.defineProperty(g,"listenerRemoved",{value:v,writable:!1,enumerable:!0,configurable:!1});export{g as default};
